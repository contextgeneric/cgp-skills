---
applyTo: '**/*.rs'
---

# Guide to Context-Generic Programming (CGP) in Rust

This guide gives you a high level overview on how to work with CGP code in Rust.

# Core Concepts

## Introduction

- CGP is a modular programming paradigm that provides workaround on the coherence restrictions in Rust.
- You can write multiple overlapping or orphan trait implementations implementations in CGP, and then wire them through a concrete context.

## Blanket Traits

- CGP evolves from the use of blanket trait implementations, also commonly called extension traits.
- This is widely used in Rust today with examples like `StreamExt` and `IterTools`. But CGP takes this concept and pushes it much further.
- The core idea of CGP is that we can use the `where` clause of a blanket trait impl to hide the constraints needed from the trait interface.
- For example, given:

```rust
pub trait CanGreet {
    fn greet(&self);
}

pub trait HasName {
    fn name(&self) -> &str;
}

impl<Context> CanGreet for Context
where
    Context: HasName,
{
    fn greet(&self) {
        println!("Hello, {}!", self.name());
    }
}
```

The blanket implementation of `CanGreet` above hides the `HasName` dependency from the trait interface.

- This concept of hiding constraints inside blanket impls is also known as impl-side dependencies, or dependency injection.

- Blanket traits are preferred over generic functions, because they provide cleaner interface and don't require the caller to specify all constraints, in case if the caller is also generic.
- For example, if `CanGreet` is defined as a generic function instead:

```rust
pub fn greet<Context>(context: &Context)
where
    Context: HasName,
{
    println!("Hello, {}!", context.name());
}
```

then the all transitive callers of `greet` would also need to specify the `Context: HasName` constraint, which can be tedious to manage.

- Note that blanket traits are not CGP components, but it is commonly used together with CGP.
- In particular, it is preferred to start writing generic code as blanket traits instead of generic functions first. And then if there is a need for multiple alternative implementations, we can easily convert the blanket trait into a CGP component later.

## Prelude

- Almost all CGP constructs are imported through the prelude:

```rust
use cgp::prelude::*;
```

## `#[cgp_component]` Macro

- The `#[cgp_component]` macro is used to enable CGP capabilities on a trait. For example:

```rust
#[cgp_component(HashProvider)]
pub trait CanHash {
    fn hash<H: Hasher>(&self, state: &mut H);
}
```

- The original trait, i.e. `CanHash`, is now called a **consumer trait**.
- A CGP consumer trait is typically named in the verb format, e.g. `CanDoSomething`.
- We also call the fully expanded constructs a CGP trait, or a CGP component. For example, the full constructs can be called the `HashProvider` component.

## Provider Traits

- The argument to `#[cgp_component]` is the name of the **provider trait**, which is generated by the macro as follows:

```rust
pub trait HashProvider<Context> {
    fn hash<H: Hasher>(context: &Context, state: &mut H);
}
```

- In the provider trait, the original `Self` type is moved to an explicit generic parameter called `Context`.
- All references to the original `self` or `Self` are converted to refer to `context` or `Context`.
- The new `Self` position in the provider trait will be implemented by unique and dummy provider types, which will act as the provider's name.
- A CGP provider trait is typically named in the noun format, e.g. `SomethingDoer`. When no suitable postfix is avaiable, the `Provider` postfix is used instead, e.g. `SomethingProvider`.


- For example, one can write a blanket implementation for `HashProvider` as follows:

```rust
pub struct HashWithDisplay;

impl<Context: Display> HashProvider<Context> for HashWithDisplay { ... }
```

- The provider name `HashWithDisplay` is defined as a local dummy struct.
- The implementation of `HashProvider` can be generic over any `Context` type that implements `Display`.
- The usual coherence restrictions don't apply, because the `Self` type `HashWithDisplay` is owned by the same crate.
- This allows any number of such blanket provider trait implementations to be defined in any crate.

## Component Name

- The macro generates a component name type with a `Component` postfix, i.e.:

```rust
pub struct HashProviderComponent;
```

- The macro also generates blanket implementations to allow delegation of the implementation of a consumer or provider trait to a different provider, which will be explained later.

## `IsProviderFor` Trait

- CGP uses `IsProviderFor` as a hack to force the Rust compiler to show the appropriate error message when there is an unsatisfied dependency:

```rust
pub trait IsProviderFor<Component, Context, Params: ?Sized = ()> {}
```

- The trait is used as a dummy marker trait that can be trivially implemented, but is deliberately implemented with additional constraints to capture the dependencies to be shown in compile errors.

- The earlier example provider trait definition for `HashProvider` was a simplification, the actual definition is:

```rust
pub trait HashProvider<Context>: IsProviderFor<HashProviderComponent, Context> {
    fn hash<H: Hasher>(context: &Context, state: &mut H);
}
```

- The first argument to `IsProviderFor` is the component name, i.e. `HashProviderComponent`. The second argument is the `Context` type. The third argument captures any additional generic parameters as a tuple.
- When implementing a provider trait, the provider also needs to implement `IsProviderFor` with the same constraints it uses to implement the provider trait. For example:

```rust
impl<Context: Display> IsProviderFor<HashProviderComponent, Context> for HashWithDisplay {}
```

- This will ensure that if a concrete context does not implement `Display`, the error will show the missing dependency via `IsProviderFor`.

## `#[cgp_provider]` Macro

- The `#[cgp_provider]` macro removes the need to manually implement `IsProviderFor`, by auto generating the implementation from the provider impl.
- The `#[cgp_new_provider]` macro has the same behavior as `#[cgp_provider]`, but also defines the provider struct automatically.
- For example, the following:

```rust
#[cgp_new_provider]
impl<Context: Display> HashProvider<Context> for HashWithDisplay { ... }
```

is the same as:

```rust
pub struct HashWithDisplay;

#[cgp_provider]
impl<Context: Display> HashProvider<Context> for HashWithDisplay { ... }
```

which is desugared to:

```rust
impl<Context: Display> HashProvider<Context> for HashWithDisplay { ... }
impl<Context: Display> IsProviderFor<HashProviderComponent, Context> for HashWithDisplay {}
```

- Whenever possible, avoid mentioning `IsProviderFor` to the user, and use the simplified provider trait definition.
- When error messages say that `IsProviderFor` is not implemented, translate it to mean that the provider trait is not implemented.

## `#[cgp_impl]` Macro

- The `#[cgp_impl]` macro further simplify the definition of provider implementations, to make it look less confusing to readers.
- For example:

```rust
#[cgp_impl(new HashWithDisplay)]
impl<Context: Display> HashProvider for Context { ... }
```

is the same as:

```rust
#[cgp_new_provider]
impl<Context: Display> HashProvider<Context> for HashWithDisplay { ... }
```

- The `Context` parameter in `#[cgp_impl]` is in the same `Self` position as the consumer trait, to make it look like blanket implementations.
- The provider name is specified in the attribute argument for `#[cgp_impl]`. An optional `new` keyword can be given to automatically define the provider struct.
- The macro also allows the use of `self` and `Self` to refer to the `Context` value and type.
- Behind the scenes, the `#[cgp_impl]` macro desugars to `#[cgp_provider]` by moving the `Context` type back to the first generic parameter of the provider trait, and use the given provider name type as the `Self` type.
- Behind the scenes, all references to `self` or `Self` are automatically converted by `#[cgp_impl]` back to refer to the explicit `context` or `Context`.

- Whenever possible, use `#[cgp_impl]` to write and explain provider implementations. Avoid showing the user `#[cgp_provider]` or `IsProviderFor`, unless they are needed to explain the internal mechanics of CGP.

## `DelegateComponent` Trait

- The `DelegateComponent` trait is defined as follows:

```rust
pub trait DelegateComponent<Component: ?Sized> {
    type Delegate;
}
```

- This is mainly used to turn a type implementing `DelegateComponent` into a type-level table.
- The `Component` generic parameter acts as the "key" type, and the `Delegate` associated type acts as the "value" type to be read from the type-level table.

- For example, given the following:

```rust
impl DelegateComponent<Foo> for MyComponents {
    type Delegate = Bar;
}
```

- The code above "sets"  the entry `Foo` in the `MyComponents` table to have `Bar` as the "value" type.

## Consumer Trait Delegation

- The `#[cgp_component]` macro generates the following blanket implementation for the example `CanHash` consumer trait earlier:

```rust
impl<Context> CanHash for Context
where
    Context: DelegateComponent<HashProviderComponent>,
    Context::Delegate: HashProvider<Context>,
{
    fn hash<H: Hasher>(&self, state: &mut H) {
        Context::Delegate::hash(self, state)
    }
}
```

- The blanket implementation essentially uses the generated `HashProviderComponent` struct as a key, and reads the entry stored on `Context`'s type-level table.
- If the `Delegate` "value" type implements the provider trait `HashProvider` for the `Context` type, then `Context` would automatically implement the `CanHash` consumer trait through the blanket implementation.
- The example `CanHash` method body is implemented by calling the `CanHash` method from the delegated provider.

- Following the earlier example, this allows the consumer trait to be defined on a custom context such as follows:

```rust
pub struct Person { ... }
impl Display for Person { ... }

impl DelegateComponent<HashProviderComponent> for Person {
    type Delegate = HashWithDisplay;
}
```

- The example `Person` struct above implements `Display`, and then delegate the implementation of `CanHash` to the `HashWithDisplay` provider.
- This is done by implementing `DelegateComponent` with `HashProviderComponent` used as the "key", and `HashWithDisplay` used as the "value" for `Person`'s type-level table.
- With that, `Person` now implements `CanHash` through the blanket implementation.
- This example also demonstrates how CGP solves the hash table problem.
- Whenever possible, do not show the user the generated blanket implementation for the consumer trait. Instead explain using high-level concepts like table lookup.

## Provider Trait Delegation

- The `#[cgp_component]` macro also generates a blanket implementation for the provider trait, similar to the consumer trait:

```rust
impl<Context, Provider> HashProvider<Context> for Provider
where
    Provider: DelegateComponent<HashProviderComponent>,
    Provider::Delegate: HashProvider<Context> + IsProviderFor<HashProviderComponent, Context>,
{
    fn hash<H: Hasher>(context: &Context, state: &mut H) {
        Context::Delegate::hash(context, state)
    }
}
```

- Essentially, this allows a provider to delegate the implementation of a provider trait to another provider.
- The blanket implementation use `Provider` as the type-level table, and perform the same lookup using `HashProviderComponent` as the key.
- This is useful for constructing intermediary "tables" that assemble multiple CGP providers that implement different CGP components.
- The additional `IsProviderFor` constraint is used to forward the constraints in the provider trait implementation down the delegation chain.
    - If possible, avoid showing the `IsProviderFor` constraint when explaining to the user the high level concepts.

- Whenever possible, do not show the user the generated blanket implementation for the provider trait. Instead explain using high-level concepts like table lookup.

## `delegate_components!` Macro

- The `delegate_components!` macro is commonly used to simplify the definition of type-level tables through the `DelegateComponent` trait.
- For example, the earlier example delegation for `Person` can be redefined as:

```rust
delegate_components! {
    Person {
        HashProviderComponent:
            HashWithDisplay,
    }
}
```

- The first argument to `delegate_components!`, i.e. `Person`, designates the target type where the type-level table is defined, or which the `DelegateComponent` trait will be implemented by.

- The `delegate_components!` macro also supports array syntax, in case when multiple type-level keys map to the same value. For example:

```rust
delegate_components! {
    MyComponents {
        [
            FooComponent,
            BarComponent,
        ]:
            FooBarProvider,
        BazComponent:
            BazProvider,
    }
}
```

is the same as:

```rust
delegate_components! {
    MyComponents {
        FooComponent:
            FooBarProvider,
        BarComponent:
            FooBarProvider,
        BazComponent:
            BazProvider,
    }
}
```

which is eventually desugared to:

```rust
impl DelegateComponent<FooComponent> for MyComponents {
    type Delegate = FooBarProvider;
}

impl DelegateComponent<BarComponent> for MyComponents {
    type Delegate = FooBarProvider;
}

impl DelegateComponent<BazComponent> for MyComponents {
    type Delegate = BazProvider;
}
```

- The `delegate_components!` macro supports an optional `new` keyword in front of the target table type, to automatically define the type for the user. For example:

```rust
delegate_components! {
    new MyComponents {
        FooComponent:
            FooBarProvider,
        ...
    }
}
```

would also generate a `struct MyComponents;` definition.

- Whenever possible, do not show the user the use of the `DelegateComponent` trait. Instead explain to them using high level concepts, such as that a type-level table is constructed for `MyComponents` using `delegate_components!`.

### `IsProviderFor` Delegation

- The `delegate_components!` macro also generates the `IsProviderFor` implementation in addition to the `DelegateComponent` trait.

- So given the code:

```rust
delegate_components! {
    MyComponents {
        FooComponent:
            FooBarProvider,
    }
}
```

the full desugaring is actually:

```rust
impl DelegateComponent<FooComponent> for MyComponents {
    type Delegate = FooBarProvider;
}

impl<Context, Params> IsProviderFor<FooComponent, Context, Params> for MyComponents
where
    FooBarProvider: IsProviderFor<FooComponent, Context, Params>
{}
```

- This helps the propagation of the provider trait constraints, in case if `MyComponents` is used as a provider and used for a constraint like `MyComponents: FooProvider<MyContext>`.
- Whenever possible, try to avoid mentioning the generation of the `IsProviderFor` implementation inside `delegate_components!`.

## Type-Level List

- CGP commonly uses type-level lists, a.k.a product types, to represent a list of types.
- A type-level list is defined as `Product![A, B, C]`, which is desugared as:

```rust
π<A, π<B, π<C, ε>>>
```

or in a human-readable form:


```rust
Cons<A, Cons<B, Cons<C, Nil>>>
```

- The types `Cons` and `Nil` are defined as:

```rust
pub struct π<Head, Tail>(pub Head, pub Tail);
pub struct ε;
pub use {ε as Nil, π as Cons};
```

- The greek alphabets like `π` and `ε` are used to shorten the representation of these types when displayed by the Rust compiler in places like error messages.
    - Whenever possible, you should prefer the syntactic sugar forms like `Product!` or the human readable forms like `Cons`.

## Type-Level Strings

- CGP uses type-level strings to represent field names as types, in the form of `Symbol!("string value")`.
- The macro desugars a type-level string like `Symbol!("abc")` into follows:

```rust
ψ<3, ζ<'a', ζ<'b', ζ<'c', ε>>>>
```

or in a readable form:

```rust
Symbol<3, Chars<'a', Chars<'b', Chars<'c', Nil>>>>
```

- The types `Symbol` and `Chars` are defined as:

```rust
pub struct ζ<const CHAR: char, Tail>(pub PhantomData<Tail>);
pub struct ψ<const LEN: usize, Chars>(pub PhantomData<Chars>);
pub use {ψ as Symbol, ζ as Chars};
```

- The `Chars` type is essentially a short hand for defining a type-level list of characters.
- The `Symbol` type is used to compute the string length at compile time. This is to workaround the lack of const-generics evaluation in stable Rust.

## `Index` Type

- CGP supports use of type-level natural numbers through the `Index` type, a.k.a. `δ`, which is defined as:

```rust
pub struct δ<const I: usize>;
pub use δ as Index;
```

- The `Index` type can be used to represent indices as types, such as `Index<0>`, `δ<1>`.

## `HasField` Trait

- The most basic use case for CGP is for dependency injection of getting values from the context.
- This is done through the `HasField` trait, which is defined as follows:

```rust
pub trait HasField<Tag> {
    type Value;

    fn get_field(&self, _tag: PhantomData<Tag>) -> &Self::Value;
}
```

- The `Tag` type is used to refer to a field in a struct, such as `Symbol!("name")` or `Index<0>`.
- The `_tag` parameter with `PhantomData` type is used to assist type inference to inform the Rust compiler of the `Tag` type, in case when multiple `HasField` implementations are in scope.
- The `HasField` trait can be automatically derived. For example:

```rust
#[derive(HasField)]
pub struct Person {
    pub name: String,
    pub age: u8,
}
```

will generate the following `HasField` impls:

```rust
impl HasField<Symbol!("name")> for Person {
    type Value = String;

    fn value(&self, _tag: PhantomData<Symbol!("name")>) -> &String {
        &self.name
    }
}

impl HasField<Symbol!("age")> for Person {
    type Value = u8;

    fn value(&self, _tag: PhantomData<Symbol!("age")>) -> &u8 {
        &self.age
    }
}
```

- The `HasField` trait can also derived for structs with unnamed fields, and uses `Index` to refer to the field indices. For example:

```rust
#[derive(HasField)]
pub struct Person(String);
```

will generate:

```rust
impl HasField<Index<0>> for Person {
    type Value = String;

    fn value(&self, _tag: PhantomData<Index<0>>) -> &String {
        &self.0
    }
}
```

## Dependency Injection

- CGP leverages Rust's trait system to enable dependency injection, also called impl-side dependencies.
- The dependency injection is done in the form of constraints specified only in the `where` clause of `impl` blocks, but not in the trait definition.
- For example, given:

```rust
#[cgp_component(Greeter)]
pub trait CanGreet {
    fn greet(&self);
}
```

Using `HasField`, one can perform dependency injection to retrieve a string value from the context, and implement a `Greeter` provider as follows:

```rust
pub struct GreetHello;

impl<Context> Greeter<Context> for GreetHello
where
    Context: HasField<Symbol!("name"), Value = String>,
{
    fn greet(context: &Context) {
        println!("Hello, {}!", context.get_field(PhantomData));
    }
}
```

- This allows `CanGreet` to be implemented on any concrete context struct that derives `HasField` and contains a `name` field of type `String`. For example:

```rust
#[derive(HasField)]
pub struct Person {
    pub name: String,
}

delegate_components! {
    Person {
        GreeterComponent:
            GreetHello,
    }
}
```

- The dependency injection technique can also be used in vanilla Rust traits with blanket implementations, such as:

```rust
pub trait CanGreet {
    fn greet(&self);
}

impl<Context> Greeter for Context
where
    Context: HasField<Symbol!("name"), Value = String>,
{
    fn greet(&self) {
        println!("Hello, {}!", self.get_field(PhantomData));
    }
}
```

- This is commonly used to hide the constraints of one implementation behind a trait interface, without using `#[cgp_component]` to enable multiple alternative implementations.
    - This is useful to simplify the learning curve of CGP, as users can mostly work with vanilla Rust traits.

## `#[cgp_auto_getter]` Macro

- `#[cgp_auto_getter]` macro provides additional abstraction on top of `HasField`, so that users don't need to understand the internals of `HasField`.
- For example, given:

```rust
#[cgp_auto_getter]
pub trait HasName {
    fn name(&self) -> &String;
}
```

the macro would generate the following blanket implementation:

```rust
impl<Context> HasName for Context
where
    Context: HasField<Symbol!("name"), Value = String>,
{
    fn name(&self) -> &str {
        self.get_field(PhantomData).as_str()
    }
}
```

- The `#[cgp_auto_getter]` macro generates blanket impls that use `HasField` implementations with the field name as the `Tag` type, and the return type as the `Value` type.
- The macro supports short hand for several return types such as `&str`, to make the `name` method more ergonomic. So we can rewrite the same trait as:

```rust
#[cgp_auto_getter]
pub trait HasName {
    fn name(&self) -> &str;
}
```

## `#[cgp_getter]` Macro

- The `#[cgp_getter]` macro is an extension to `#[cgp_component]` that provides similar feature as `#[cgp_auto_getter]`, but allows the getter field to be customized through CGP.
- For example, given:

```rust
#[cgp_getter]
pub trait HasName {
    fn name(&self) -> &str;
}
```

is the same as writing:

```rust
#[cgp_component(NameGetter)]
pub trait HasName {
    fn name(&self) -> &str;
}
```

but also has the following `UseField` provider implemented:

```rust
#[cgp_impl(UseField<Tag>)]
impl<Context, Tag> NameGetter for Context
where
    Context: HasField<Tag, Value = String>,
{
    fn name(&self) -> &str {
        self.get_field(PhantomData)
    }
}
```

## `UseField` Pattern

- CGP defines the `UseField` type as a general target for implementing getter providers by `#[cgp_getter]`.
- The `UseField` provider accepts a generic `Tag` parameter that represents the name of the field from the context to be used to implement the getter.
- The `Tag` in `UseField` can use a different name as the getter method, allowing greater flexibility than `#[cgp_auto_getter]` which always require the context to have a field with the exact same name.
- For example, one can have the following wiring:

```rust
#[derive(HasField)]
pub struct Person {
    pub person_name: String,
}

delegate_components! {
    Person {
        NameGetterComponent:
            UseField<Symbol!("person_name")>,
    }
}
```

the example `UseField` provider will use the `person_name` field in `Person` to implement the `NameGetter::name`.

- Whenever possible, explain the `UseField` provider by saying that it implements the getter trait by reading from the context the field name specified.
    - For example, `Person` implements `HasName` using its `person_name` field.

## Abstract Types

- CGP supports abstract types by defining associated types in CGP traits. For example:

```rust
#[cgp_component(NameTypeProviderComponent)]
pub trait HasNameType {
    type Name;
}
```

- The abstract type can be used in another trait interface as the super trait, such as:

```rust
#[cgp_auto_getter]
pub trait HasName: HasNameType {
    fn name(&name) -> &Self::Name;
}
```

## `#[cgp_type]` Macro

- CGP provides the `#[cgp_type]` macro that can be used in place of `#[cgp_component]` to define abstract type traits.
- For example, the `HasNameType` trait can be redefined as:

```rust
#[cgp_type]
pub trait HasNameType {
    type Name;
}
```

- If no provider name is given in `#[cgp_type]`, a default provider name with the type name plus `TypeProvider` postfix is used. So the above code is the same as:

```rust
#[cgp_type(NameTypeProvider)]
pub trait HasNameType {
    type Name;
}
```

- `#[cgp_type]` has the same base behavior as `#[cgp_component]`, but generates additional constructs such as a blanket implementation for `UseType`:

```rust
#[cgp_impl(UseType<Name>)]
impl<Context, Name> NameTypeProvider for Context {
    type Name = Name;
}
```

- The `UseType` struct is defined by CGP, which is implemented by providers that use `#[cgp_type]` as a design pattern.
- The `UseType` pattern allows a concrete context to implement an abstract type by delegating it to `UseType`. For example:

```rust
delegate_components! {
    Person {
        NameTypeProviderComponent:
            UseType<String>,
    }
}
```

would implement `HasNameType` for `Person` with `Name` being implemented as `String`.

## Generic Parameters

- CGP traits can also contain generic parameters, for example:

```rust
#[cgp_component(ValueDeserializer)]
pub trait CanDeserializeValue<'de, Value> {
    fn deserialize<D>(&self, deserializer: D) -> Result<Value, D::Error>
    where
        D: serde::Deserializer<'de>;
}
```

defines a modular version of `serde`'s `Deserialize` trait, with the value serialization provider configurable for each context.

- When the provider trait is generated, the generic parameters are appended after the `Context` parameter.
- In the `IsProviderFor` supertrait, all generic parameters a grouped together into a tuple and placed in the last `Params` position.
- Lifetime generic parameters are wrapped in the `Life` type, which lifts lifetimes into types:

```rust
pub struct Life<'a>(pub PhantomData<*mut &'a ()>);
````

- For example, the `ValueDeserializer` provider trait would be defined as:

```rust
pub trait ValueDeserializer<'de, Context, Value>:
    IsProviderFor<ValueDeserializerComponent, Context, (Life<'de>, Value)>
{
    fn deserialize<D>(context: &Context, deserializer: D) -> Result<Value, D::Error>
    where
        D: serde::Deserializer<'de>;
}
```

## `UseDelegate` Provider

- For traits containing generic parameters, the `#[cgp_component]` macro supports additional option to generate `UseDelegate` providers that dispatch providers based on the generic type using an inner table.

- For example, given:

```rust
#[cgp_component {
    provider: ValueDeserializer,
    derive_delegate: UseDelegate<Value>,
}]
pub trait CanDeserializeValue<'de, Value> {
    fn deserialize<D>(&self, deserializer: D) -> Result<Value, D::Error>
    where
        D: serde::Deserializer<'de>;
}
```

The following provider will be generated:

```rust
#[cgp_impl(UseDelegate<Components>)]
impl<'de, Context, Value, Components> ValueDeserializer<'de, Value> for Context
where
    Components: DelegateComponent<Value>,
    Components::Delegate: ValueDeserializer<'de, Value>,
{
    fn deserialize<D>(&self, deserializer: D) -> Result<Value, D::Error>
    where
        D: serde::Deserializer<'de>
    {
        Components::Delegate::deserialize(self, deserializer)
    }
}
```

- Only the generic type specified in `UseDelegate`'s generic parameter will be used as the key. For example, the `UseDelegate` provider above dispatches based on `Value`, but not `'de`.
- The `UseDelegate` type is defined by CGP, but one can define and use other delegate providers in similar ways. For example:

```rust
pub struct UseInputDelegate;

#[cgp_component {
    provider: Computer,
    derive_delegate: [
        UseDelegate<Code>,
        UseInputDelegate<Input>,
    ],
}]
pub trait CanCompute<Code, Input> {
    type Output;

    fn compute(&self, _code: PhantomData<Code>, input: Input) -> Self::Output;
}
```

the `CanCompute` trait above defines two delegate providers. The default `UseDelegate` provider dispatches based on the `Code` type, while the local `UseInputDelegate` provider dispatches based on the `Input` type.

## Nested Table Definition

- `delegate_components!` supports defining nested type-level tables within the outer table definition.
- For example:

```rust
delegate_components! {
    MyApp {
        ErrorTypeProviderComponent:
            UseType<anyhow::Error>,
        ValueSerializerComponent:
            UseDelegate<new ValueSerializerComponents {
                u64: UseSerde,
                Person: SerializeWithDisplay,
                ...
            }>,
        ...
    }
}
```

is the same as:

```rust
delegate_components! {
    MyApp {
        ErrorTypeProviderComponent:
            UseType<anyhow::Error>,
        ValueSerializerComponent:
            UseDelegate<ValueSerializerComponents>,
        ...
    }
}

delegate_components! {
    new ValueSerializerComponents {
        u64: UseSerde,
        Person: SerializeWithDisplay,
        ...
    }
}
```

The example above helps `App` to implement `CanSerializeValue<u64>` by delegating to the `UseSerde` provider, and `CanSerializeValue<Person>` to `SerializeWithDisplay`, via the `UseDelegate` provider using `ValueSerializerComponents` as the inner lookup table based on the `Value` types.

## Check Traits

- The CGP component wiring is lazy, i.e. when a `DelegateComponent` impl is defined, the type system doesn't check whether the corresponding traits are truly implemented by a context with all transitive dependencies satisfied.
- When a consumer trait is used with a context, but there are unsatisfied dependencies, the compiler will produce short error messages that are difficult to debug and identify the root cause.
- To ensure that a consumer is implemented by a context, we implement check traits to assert at compile time that the wiring is complete.

- For example, given:

```rust
#[cgp_auto_getter]
pub trait HasName {
    fn name(&self) -> &str;
}

#[cgp_component(Greeter)]
pub trait CanGreet {
    fn greet(&self);
}

#[cgp_impl(new GreetHello)]
impl<Context> Greeter for Context
where
    Context: HasName,
{
    fn greet(&self) {
        println!("Hello, {}!", self.name());
    }
}

#[derive(HasField)]
pub struct Person {
    pub first_name: String,
}

delegate_components! {
    Person {
        GreeterComponent:
            GreetHello,
    }
}
```

The `Person` struct above incorrectly contains a `first_name` field, instead of the `name` field expected by `GreetHello` via `HasName`.

- We can write a check trait to check whether `Person` implements `CanGreet` as follows:

```rust
trait CanUsePerson: CanGreet {}
impl CanUsePerson for Person {}
```

- A check trait like `CanUsePerson` is a dummy trait that includes the dependencies that we want to check as its super trait.
- The check trait contains an empty body that can be trivially implemented if all the supertrait constraints are satisfied.
- We then implement the check trait for the context type that we want to check. If the type also implements all the supertraits, then the implementation is successful and the test passes.

## `CanUseComponent` Trait

- It is insufficient to use check traits alone in case when a check fails. This is because Rust would not produce sufficient details in the error message to help inform us on what dependency is missing.
- For example, the `CanUsePerson` check earlier only output a vague error that tells us `GreetHello: Greeter<Person>` is not implemented, without telling us why.
- We can use check traits together with `CanUseComponent` as their supertraits to force the Rust compiler to show more error details.
- The `CanUseComponent` trait is a check trait defined as follows:

```rust
pub trait CanUseComponent<Component, Params: ?Sized = ()> {}

impl<Context, Component, Params: ?Sized> CanUseComponent<Component, Params> for Context
where
    Context: DelegateComponent<Component>,
    Context::Delegate: IsProviderFor<Component, Context, Params>,
{}
```

- `CanUseComponent` for a CGP component is automatically implemented for a context, if a context delegates the component to a provider, and the provider implements the provider trait for that context.
- The check is done via `IsProviderFor`, to ensure that the compiler generates appropriate error messages when there is any unsatisfied constraint.
    - Without `IsProviderFor`, Rust would conceal the indirect errors and only show that the provider trait is not implemented without providing further details.

## `check_components!` Macro

- Additionally, instead of defining the check traits manually, we can use `check_components!` to simplify the definition of the compile time tests.
- The `check_components!` macro generates code that checks the CGP wiring of components using `CanUseComponent`.

- The static check is written with `check_components!` as follow:

```rust
check_components! {
    CanUsePerson for Person {
        GreeterComponent,
    }
}
```

- Behind the scenes, the macro desugars the code above to:

```rust
trait CanUsePerson<Component, Params: ?Sized>: CanUseComponent<Component, Params> {}
impl CanUsePerson<GreeterComponent, ()> for Person {}
```

- The auxilary `CanUsePerson` trait is defined as a local alias to check the use of `CanUseComponent` with the same parameters.
- For each `Component` listed in `check_components!`, an impl block for `CanUsePerson` is defined.
- The example implementation `CanUsePerson<GreeterComponent, ()>` is implemented only if:
    - `Person` implements `CanUseComponent<Component, Params>`.
    - `Person`'s delegate for `GreeterComponent`, `GreetHello`, implements `IsProviderFor<GreeterComponent, Person, ()>`.
    - Recall that `#[cgp_impl]` or `#[cgp_provider]` generates the implementation of `GreetHello: IsProviderFor<GreeterComponent, Person, ()>` with the same constraints required for `GreetHello` to implement `Greeter<Person>`.
- Since the `name` field is missing, the compiler reports the error that `HasField<symbol!("name")>` is not implemented for `Person`.
    - The root cause is often hidden among many other non-essential messages, and types such as `symbol!("name")` are expanded into their Greek alphabets form.

## Generic Parameters in `check_components!`

- `check_components!` can only be used with generic parameters. For example:

```rust
check_components! {
    <'de> CanUseAppDerializer for App {
        ValueDeserializerComponent: (Life<'de>, u64),
    }
}
```

would be desugared to:

```rust
trait CanUseAppDerializer<Component, Params: ?Sized>:
    CanUseComponent<Component, Params>
{
}
impl<'de> CanUseAppDerializer<ValueDeserializerComponent, (Life<'de>, u64)> for App {}
```

which would check for the implementation of `App: CanDeserializeValue<'de, u64>`.

- The generic parameters are grouped into a tuple and placed in `Params`.

## Array Syntax in `check_components!`

- When we want to check the implementation of a CGP component with multiple generic parameters, we can use the array syntax to group them together. For example:

```rust
check_components! {
    CanUseAppSerializer for App {
        ValueSerializerComponent: [
            u64,
            String,
        ],
    }
}
```

is the same as writing:

```rust
check_components! {
    CanUseAppSerializer for App {
        ValueSerializerComponent: u64,
        ValueSerializerComponent: String,
    }
}
```

- We can also group by the `Component` key instead of the generic `Param`. For example:

```rust
check_components! {
    CanUseAppSerializer for App {
        [
            ValueSerializerComponent,
            AreaCalculatorComponent,
        ]: Circle,
    }
}
```

- We can also group by both `Component` and `Param`. For example:

```rust
check_components! {
    CanUseAppSerializer for App {
        [
            ValueSerializerComponent,
            AreaCalculatorComponent,
        ]: [
            Circle,
            Rectangle,
        ],
    }
}
```

would be the same as writing:


```rust
check_components! {
    CanUseAppSerializer for App {
        ValueSerializerComponent: Circle,
        AreaCalculatorComponent: Circle,
        ValueSerializerComponent: Rectangle,
        AreaCalculatorComponent: Rectangle,
    }
}
```

## Higher Order Providers

- Higher order providers is a CGP design pattern that allows providers to accept other providers as generic parameters.

- For example, with the `CanSerializeValue` trait:

```rust
#[cgp_component(ValueSerializer)]
pub trait CanSerializeValue<Value: ?Sized> {
    fn serialize<S>(&self, value: &Value, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer;
}
```

we can define a higher order provider `SerializeIteratorWith` as follows:

```rust
#[cgp_impl(new SerializeIteratorWith<Provider>)]
impl<Context, Value, Provider> ValueSerializer<Value> for Context
where
    for<'a> &'a Value: IntoIterator,
    Provider: for<'a> ValueSerializer<Context, <&'a Value as IntoIterator>::Item>,
{
    fn serialize<S>(&self, value: &Value, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    { ... }
}
```

- The behavior of the inner item serialization is now determined by the `Provider` generic parameter, instead of the context.

- This static binding behavior allows the provider implementor to choose a specific provider, as compared to leaving it to be configurable by the concrete context.
- For example, the following `SerializeIteratorWithContext` provider always uses the context to look up the inner item serializer:

```rust
#[cgp_impl(new SerializeIteratorWithContext)]
impl<Context, Value> ValueSerializer<Value> for Context
where
    for<'a> &'a Value: IntoIterator,
    Context: for<'a> CanSerializeValue<<&'a Value as IntoIterator>::Item>,
{
    fn serialize<S>(&self, value: &Value, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    { ... }
}
```

- Note that not all providers that contain generic parameters are higher order providers. They only become higher order providers when the generic parameters are used with provider trait constraints in the `where` clause.
- For example, the following provider is not a higher order provider:

```rust
#[cgp_impl(new GetName<Tag>)]
impl<Context, Tag> NameGetter for Context
where
    Context: HasField<Tag, Value = String>,
{
    fn name(&self) -> &str {
        self.get_field(PhantomData)
    }
}
```

- The code above uses the `UseField` pattern, where the `Tag` type is used as the field name to access the corresponding field value via `HasField`. But since there is no constraint for `Tag` to implement any provider trait, the provider `GetName` is not a higher order provider.


## `UseContext` Provider

- CGP defines a special `UseContext` provider that is automatically implemented for all CGP traits that are defined with macros like `#[cgp_component]`:

```rust
struct UseContext;
```

- For example, the `UseContext` implementation generated for `CanSerializeValue` is as follows:

```rust
#[cgp_impl(UseContext)]
impl<Context, Value> ValueSerializer<Value> for Context
where
    Context: CanSerializeValue<Value>,
{
    fn serialize<S>(&self, value: &Value, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.serialize(value, serializer)
    }
}
```

- There is a duality between `UseContext` and the blanket implementation of consumer traits. Whereas the blanket implementation of the `CanSerializeValue` consumer trait uses a delegated provider that implements `ValueSerializer` to implement `CanSerializeValue`, the `UseContext` provider implements the `ValueSerializer` provider trait using `CanSerializeValue` implemented by the context.
    - However, trying to delegate a consumer trait to `UseContext` would create a circular dependency, resulting in compile-time errors.
- A higher order provider may be configured to use `UseContext` as the default inner provider, so that the default provider wired in the context is used when no explicit provider is specified.
- For example, we can modify the earlier `SerializeIteratorWith` to use `UseContext` as a default provider:

```rust
pub struct SerializeIteratorWith<Provider = UseContext>(pub PhantomData<Provider>);

#[cgp_impl(SerializeIteratorWith<Provider>)]
impl<Context, Value, Provider> ValueSerializer<Value> for Context
where
    for<'a> &'a Value: IntoIterator,
    Provider: for<'a> ValueSerializer<Context, <&'a Value as IntoIterator>::Item>,
{
    fn serialize<S>(&self, value: &Value, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    { ... }
}
```

- The struct definition of `SerializeIteratorWith` is defined with `UseContext` being a default generic parameter for `Provider`.
- This way, when no explicit provider is specified, `SerializeIteratorWith` would have the same behavior as `SerializeIteratorWithContext`.
- Note that the default `UseContext` provider is only applicable for higher order providers with explicit struct definitions that contain the default generic parameter. Otherwise, there is no default provider involved, and the inner provider must always be specified explicitly.

# Modularity Hierarchy

This section summarizes the modularity hierarchy of the use of CGP and vanilla Rust constructs, using the `Serialize` trait from `serde` as the base example.

## One Implementation per Interface

- Generic functions and blanket implementations allow the definition of exactly one implementation of the interface they define.
- Example generic function:

```rust
pub fn serialize_bytes<Value: AsRef<[u8]>, S: Serializer>(value: &Value, serializer: S) -> Result<S::Ok, S::Error> { ... }
```

- Blanket traits have the same limitations, but improve the ergonomic of generic functions by hiding the constraints behind the trait impl:

```rust
pub trait CanSerializeBytes {
    fn serialize_bytes<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error>;
}

impl<Value: AsRef<[u8]>> CanSerializeBytes for Value {
    fn serialize_bytes<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> { ... }
}
```

## One Unique Implementation per Type per Interface

- Vanilla Rust traits allows multiple implementations to share the same interface, but the coherence restrictions allows at most one unique implementation per type for the interface they define.
- Example:

```rust
pub trait Serialize {
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error>
}

impl Serialize for Vec<u8> {
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        self.serialize_bytes(serializer)
    }
}

impl<'a> Serialize for &'a [u8] {
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        self.serialize_bytes(serializer)
    }
}
```

- The above example requires two explicit implementations of `Serialize` for `Vec<u8>` and `&[u8]`, even though both implementations share the same logic.
  - However, the method implementation body can make use of explicit implementations earlier such as `CanSerializeBytes` to create reusable building blocks outside of the trait system.

## Multiple Implementations per Type per Interface, Globally Unique Wiring per Type

- Basic CGP techniques can be applied on vanilla Rust traits to streamline the reuse of common implementation logic through provider traits.
- Example:

```rust
#[cgp_component(ValueSerializer)]
pub trait Serialize {
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error>
}

#[cgp_impl(new SerializeBytes)]
impl<Value: AsRef<[u8]>> ValueSerializer for Value {
    fn serialize_bytes<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> { ... }
}

delegate_components! {
    Vec<u8> {
        ValueSerializerComponent: SerializeBytes,
    }
}

delegate_components! {
    <'a> &'a [u8] {
        ValueSerializerComponent: SerializeBytes,
    }
}
```

- The main advantage of this base approach is that the original `Serialize` trait is extended without modification to the original interface. This provides backward compatibility with existing Rust traits that are already widely used.
    - A type can still implements `Serialize` directly without needing to opt in to use CGP for everything.
- The use of the `ValueSerializer` provider trait removes the need to write explicit interfaces like `CanSerializeBytes`.
- The use of `delegate_components!` removes the need to manually forward the method implementation through explicit method calls.
- The main limitation is that some coherence restrictions still apply.
    - If we have an explicit `delegate_components!` wiring of `Vec<u8>` to `SerializeBytes`, then we cannot have a separate overlapping implementation or wiring for a generic `Vec<T>`.
    - The `Serialize` implementation for a type like `Vec<u8>` cannot be easily overridden for a specific context, such as to serialize a custom `Vec<u8>` field in a struct as hex string instead of bytes.
    - The orphan rules still apply, so the use of `delegate_components!` cannot be applied to `Vec<u8>` outside of a crate that owns either `Serialize` or `Vec`.

## Multiple Implementations per Type per Interface, Unique Wiring per Type per Context

- CGP supports full decoupling of an implementation from the type being implemented, by adding an explicit context parameter to configure the wiring of multiple types within the context.
- For example, the `Serialize` trait is changed to `CanSerializeValue`, with the original `Self` type moved to become an explicit `Value` parameter:

```rust
#[cgp_component {
    provider: ValueSerializer,
    derive_delegate: UseDelegate<Value>,
}]
pub trait CanSerializeValue<Value: ?Sized> {
    fn serialize<S>(&self, value: &Value, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer;
}

delegate_components! {
    new MyAppA {
        ValueSerializerComponent:
            UseDelegate<new ValueSerializerComponents {
                Vec<u8>: SerializeBytes,
                Vec<u64>: SerializeIterator,
                ...
            }>,
    }
}

delegate_components! {
    new MyAppB {
        ValueSerializerComponent:
            UseDelegate<new ValueSerializerComponents {
                Vec<u8>: SerializeHex,
                Vec<u64>: SerializeIterator,
                ...
            }>,
    }
}
```

- This allows explicit context types like `MyAppA` and `MyAppB` to be defined with different providers chosen for a type like `Vec<u8>`.
- The orphan rules no longer apply, so a context like `MyAppA` can wire the implementation of `Vec<u8>`, even if the crate don't own `CanSerializeValue` or `Vec`, as long as the crate owns the context `AppA`.
- The coherence restrictions are almost fully lifted, since the orphan wiring of a type like `Vec` means that we don't need to commit to a global implementation for `Vec` up front.
- The main disadvantage is that the trait needs to be modified to add an explicit context parameter for wiring.
- Furthermore, explicit wiring must be specified for all types used within a context, which can be tedious.

## Multiple Implementations per Type per Interface, Explicit Wiring Per Type per Provider

- The use of higher order providers together with `UseContext` allows the wiring of the implementation of a type to be overridden within a provider, without routing it through the context.
- For example:

```rust
pub struct SerializeIteratorWith<Provider = UseContext>(pub PhantomData<Provider>);

#[cgp_impl(SerializeIteratorWith<Provider>)]
impl<Context, Value, Provider> ValueSerializer<Value> for Context
where
    for<'a> &'a Value: IntoIterator,
    Provider: for<'a> ValueSerializer<Context, <&'a Value as IntoIterator>::Item>,
{
    fn serialize<S>(&self, value: &Value, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    { ... }
}

delegate_components! {
    new MyAppA {
        ValueSerializerComponent:
            UseDelegate<new ValueSerializerComponents {
                Vec<u8>: SerializeBytes,
                Vec<Vec<u8>>: SerializeIteratorWith<SerializeHex>,
                Vec<u64>: SerializeIteratorWith,
                [
                    u8,
                    u64,
                ]:
                    UseSerde,
                ...
            }>,
    }
}
```

- In the above example, the serialization of `Vec<Vec<u8>>` would serialize the inner `Vec<u8>` as hex strings, while other `Vec<u8>` would still be serialized as bytes.
- The default parameter allows the inner item serializer to be routed through the context as usual, if no overridding is required.
    - The example `Vec<u64>` serialization would still go through the context, which result in `UseSerde` being used to serialize the `u64` items.
- This patterns allows further fine grained control of the wiring implementations that can be overridden locally on a per-provider basis, as compared a more "global" wiring at the per-context level.

# Debugging Techniques

- When compile errors are shown for a failed component wiring, try to identify the root cause by walking through the transitive dependencies shown within the error messages.
- When you suspect that a required CGP component is not implemented for a context, try include that component in `check_components!` so that the error can be narrowed down.
    - Note that not all trait are necessarily CGP component. An unsatisfied dependency can also be just regular trait or blanket trait. These dependencies cannot be verified via `check_components!`.

# General Instructions

- When interacting with the user, assume that the user only has basic Rust programming experience and is not familiar with any concept in CGP.
- Only provide further explanation for CGP concepts if the user asks for the specific explanation. Otherwise, assume that the user already understand the CGP concepts used in the code.

- When the user asks you to explain CGP concepts:
    - You should assume that the user is not familiar with advanced Rust concepts, including generics, traits, blanket implementations, and the coherence problem.
    - You should assume that the user is not familiar with functional programming and type-level programming concepts. So try to explain concepts like type-level tables, lists, or string, using more familiar OOP concepts, such as v-table lookup.
    - Use full sentences and explain CGP concepts in ways that are approachable and engaging to beginners. You should include additional explanation for advanced concepts such as generics when applicable.

- When the user ask to explain a specific wiring in `delegate_components!`, always lookup the definition of the components and providers to give more details in your explanation. For example, if the user asks you to explain the following code:

```rust
delegate_components! {
    Person {
        GretterComponent:
            GreetHello,
    }
}
```

you should look up for the definitions of `GreetComponent` and `GreetHello`. This includes finding out what are the names of the consumer trait and provider trait for `GreetComponent`, and the trait or impl body.

- When the user asks about the implementation details of a provider, always perform lookup on the original definition, and also the definition of all dependencies that the provider uses. For example, if the user asks you to explain the following:

```rust
#[cgp_impl(GreetHello)]
impl<Context> Greeter for Context
where
    Context: HasName,
{
    fn greet(&self) {
        println!("Hello, {}!", self.name());
    }
}
```

you should lookup for the definition of `Greeter` and `HasName`, and include the details of those definitions in your explanation.

- When the user asks about how a provider is implemented for a context, also perform lookup based on the specific wiring for the context, and find out what other providers that implementation is linked to. For example, if you need to explain `GreetHello`, and you find the following wiring:

```rust
delegate_components! {
    Person {
        NameGetterComponent:
            UseField<"person_name">,
        GretterComponent:
            GreetHello,
    }
}
```

then you should explain that for the `Person` context, since `NameGetterComponent` is wired to `UseField<"person_name">`, so when `println!("Hello, {}!", self.name())` is called from `GreetHello`, the value from `person_name` field will be returned from `self.name()`.
