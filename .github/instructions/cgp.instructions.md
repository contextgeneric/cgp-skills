---
applyTo: '**/*.rs'
---

# Guide to Context-Generic Programming (CGP) in Rust

This guide gives you a high level overview on how to work with CGP code in Rust.

# Core Concepts

## Introduction

- CGP is a modular programming paradigm that provides workaround on the coherence restrictions in Rust.
- You can write multiple overlapping or orphan trait implementations implementations in CGP, and then wire them through a concrete context.

## Prelude

- Almost all CGP constructs are imported through the prelude:

```rust
use cgp::prelude::*;
```

## `#[cgp_component]` Macro

- The `#[cgp_component]` macro is used to enable CGP capabilities on a trait. For example:

```rust
#[cgp_component(HashProvider)]
pub trait CanHash {
    fn hash<H: Hasher>(&self, state: &mut H);
}
```

- The original trait, i.e. `CanHash`, is now called a **consumer trait**.
- A CGP consumer trait is typically named in the verb format, e.g. `CanDoSomething`.
- We also call the fully expanded constructs a CGP trait, or a CGP component. For example, the full constructs can be called the `HashProvider` component.

## Provider Traits

- The argument to `#[cgp_component]` is the name of the **provider trait**, which is generated by the macro as follows:

```rust
pub trait HashProvider<Context> {
    fn hash<H: Hasher>(context: &Context, state: &mut H);
}
```

- In the provider trait, the original `Self` type is moved to an explicit generic parameter called `Context`.
- All references to the original `self` or `Self` are converted to refer to `context` or `Context`.
- The new `Self` position in the provider trait will be implemented by unique and dummy provider types, which will act as the provider's name.
- A CGP provider trait is typically named in the noun format, e.g. `SomethingDoer`. When no suitable postfix is avaiable, the `Provider` postfix is used instead, e.g. `SomethingProvider`.


- For example, one can write a blanket implementation for `HashProvider` as follows:

```rust
pub struct HashWithDisplay;

impl<Context: Display> HashProvider<Context> for HashWithDisplay { ... }
```

- The provider name `HashWithDisplay` is defined as a local dummy struct.
- The implementation of `HashProvider` can be generic over any `Context` type that implements `Display`.
- The usual coherence restrictions don't apply, because the `Self` type `HashWithDisplay` is owned by the same crate.
- This allows any number of such blanket provider trait implementations to be defined in any crate.

## Component Name

- The macro generates a component name type with a `Component` postfix, i.e.:

```rust
pub struct HashProviderComponent;
```

- The macro also generates blanket implementations to allow delegation of the implementation of a consumer or provider trait to a different provider, which will be explained later.

## `IsProviderFor` Trait

- CGP uses `IsProviderFor` as a hack to force the Rust compiler to show the appropriate error message when there is an unsatisfied dependency:

```rust
pub trait IsProviderFor<Component, Context, Params: ?Sized = ()> {}
```

- The trait is used as a dummy marker trait that can be trivially implemented, but is deliberately implemented with additional constraints to capture the dependencies to be shown in compile errors.

- The earlier example provider trait definition for `HashProvider` was a simplification, the actual definition is:

```rust
pub trait HashProvider<Context>: IsProviderFor<HashProviderComponent, Context> {
    fn hash<H: Hasher>(context: &Context, state: &mut H);
}
```

- The first argument to `IsProviderFor` is the component name, i.e. `HashProviderComponent`. The second argument is the `Context` type. The third argument captures any additional generic parameters as a tuple.
- When implementing a provider trait, the provider also needs to implement `IsProviderFor` with the same constraints it uses to implement the provider trait. For example:

```rust
impl<Context: Display> IsProviderFor<HashProviderComponent, Context> for HashWithDisplay {}
```

- This will ensure that if a concrete context does not implement `Display`, the error will show the missing dependency via `IsProviderFor`.

## `#[cgp_provider]` Macro

- The `#[cgp_provider]` macro removes the need to manually implement `IsProviderFor`, by auto generating the implementation from the provider impl.
- The `#[cgp_new_provider]` macro has the same behavior as `#[cgp_provider]`, but also defines the provider struct automatically.
- For example, the following:

```rust
#[cgp_new_provider]
impl<Context: Display> HashProvider<Context> for HashWithDisplay { ... }
```

is the same as:

```rust
pub struct HashWithDisplay;

#[cgp_provider]
impl<Context: Display> HashProvider<Context> for HashWithDisplay { ... }
```

which is desugared to:

```rust
impl<Context: Display> HashProvider<Context> for HashWithDisplay { ... }
impl<Context: Display> IsProviderFor<HashProviderComponent, Context> for HashWithDisplay {}
```

- Whenever possible, avoid mentioning `IsProviderFor` to the user, and use the simplified provider trait definition.
- When error messages say that `IsProviderFor` is not implemented, translate it to mean that the provider trait is not implemented.

## `#[cgp_impl]` Macro

- The `#[cgp_impl]` macro further simplify the definition of provider implementations, to make it look less confusing to readers.
- For example:

```rust
#[cgp_impl(new HashWithDisplay)]
impl<Context: Display> HashProvider for Context { ... }
```

is the same as:

```rust
#[cgp_new_provider]
impl<Context: Display> HashProvider<Context> for HashWithDisplay { ... }
```

- The `Context` parameter in `#[cgp_impl]` is in the same `Self` position as the consumer trait, to make it look like blanket implementations.
- The provider name is specified in the attribute argument for `#[cgp_impl]`. An optional `new` keyword can be given to automatically define the provider struct.
- The macro also allows the use of `self` and `Self` to refer to the `Context` value and type.
- Behind the scenes, the `#[cgp_impl]` macro desugars to `#[cgp_provider]` by moving the `Context` type back to the first generic parameter of the provider trait, and use the given provider name type as the `Self` type.
- Behind the scenes, all references to `self` or `Self` are automatically converted by `#[cgp_impl]` back to refer to the explicit `context` or `Context`.

- Whenever possible, use `#[cgp_impl]` to write and explain provider implementations. Avoid showing the user `#[cgp_provider]` or `IsProviderFor`, unless they are needed to explain the internal mechanics of CGP.

## `DelegateComponent` Trait

- The `DelegateComponent` trait is defined as follows:

```rust
pub trait DelegateComponent<Component: ?Sized> {
    type Delegate;
}
```

- This is mainly used to turn a type implementing `DelegateComponent` into a type-level table.
- The `Component` generic parameter acts as the "key" type, and the `Delegate` associated type acts as the "value" type to be read from the type-level table.

- For example, given the following:

```rust
impl DelegateComponent<Foo> for MyComponents {
    type Delegate = Bar;
}
```

- The code above "sets"  the entry `Foo` in the `MyComponents` table to have `Bar` as the "value" type.

## Consumer Trait Delegation

- The `#[cgp_component]` macro generates the following blanket implementation for the example `CanHash` consumer trait earlier:

```rust
impl<Context> CanHash for Context
where
    Context: DelegateComponent<HashProviderComponent>,
    Context::Delegate: HashProvider<Context>,
{
    fn hash<H: Hasher>(&self, state: &mut H) {
        Context::Delegate::hash(self, state)
    }
}
```

- The blanket implementation essentially uses the generated `HashProviderComponent` struct as a key, and reads the entry stored on `Context`'s type-level table.
- If the `Delegate` "value" type implements the provider trait `HashProvider` for the `Context` type, then `Context` would automatically implement the `CanHash` consumer trait through the blanket implementation.
- The example `CanHash` method body is implemented by calling the `CanHash` method from the delegated provider.

- Following the earlier example, this allows the consumer trait to be defined on a custom context such as follows:

```rust
pub struct Person { ... }
impl Display for Person { ... }

impl DelegateComponent<HashProviderComponent> for Person {
    type Delegate = HashWithDisplay;
}
```

- The example `Person` struct above implements `Display`, and then delegate the implementation of `CanHash` to the `HashWithDisplay` provider.
- This is done by implementing `DelegateComponent` with `HashProviderComponent` used as the "key", and `HashWithDisplay` used as the "value" for `Person`'s type-level table.
- With that, `Person` now implements `CanHash` through the blanket implementation.
- This example also demonstrates how CGP solves the hash table problem.
- Whenever possible, do not show the user the generated blanket implementation for the consumer trait. Instead explain using high-level concepts like table lookup.

## Provider Trait Delegation

- The `#[cgp_component]` macro also generates a blanket implementation for the provider trait, similar to the consumer trait:

```rust
impl<Context, Provider> HashProvider<Context> for Provider
where
    Provider: DelegateComponent<HashProviderComponent>,
    Provider::Delegate: HashProvider<Context> + IsProviderFor<HashProviderComponent, Context>,
{
    fn hash<H: Hasher>(context: &Context, state: &mut H) {
        Context::Delegate::hash(context, state)
    }
}
```

- Essentially, this allows a provider to delegate the implementation of a provider trait to another provider.
- The blanket implementation use `Provider` as the type-level table, and perform the same lookup using `HashProviderComponent` as the key.
- This is useful for constructing intermediary "tables" that assemble multiple CGP providers that implement different CGP components.
- The additional `IsProviderFor` constraint is used to forward the constraints in the provider trait implementation down the delegation chain.
    - If possible, avoid showing the `IsProviderFor` constraint when explaining to the user the high level concepts.

- Whenever possible, do not show the user the generated blanket implementation for the provider trait. Instead explain using high-level concepts like table lookup.

## `delegate_components!` Macro

- The `delegate_components!` macro is commonly used to simplify the definition of type-level tables through the `DelegateComponent` trait.
- For example, the earlier example delegation for `Person` can be redefined as:

```rust
delegate_components! {
    Person {
        HashProviderComponent:
            HashWithDisplay,
    }
}
```

- The first argument to `delegate_components!`, i.e. `Person`, designates the target type where the type-level table is defined, or which the `DelegateComponent` trait will be implemented by.

- The `delegate_components!` macro also supports array syntax, in case when multiple type-level keys map to the same value. For example:

```rust
delegate_components! {
    MyComponents {
        [
            FooComponent,
            BarComponent,
        ]:
            FooBarProvider,
        BazComponent:
            BazProvider,
    }
}
```

is the same as:

```rust
delegate_components! {
    MyComponents {
        FooComponent:
            FooBarProvider,
        BarComponent:
            FooBarProvider,
        BazComponent:
            BazProvider,
    }
}
```

which is eventually desugared to:

```rust
impl DelegateComponent<FooComponent> for MyComponents {
    type Delegate = FooBarProvider;
}

impl DelegateComponent<BarComponent> for MyComponents {
    type Delegate = FooBarProvider;
}

impl DelegateComponent<BazComponent> for MyComponents {
    type Delegate = BazProvider;
}
```

- The `delegate_components!` macro supports an optional `new` keyword in front of the target table type, to automatically define the type for the user. For example:

```rust
delegate_components! {
    new MyComponents {
        FooComponent:
            FooBarProvider,
        ...
    }
}
```

would also generate a `struct MyComponents;` definition.

- Whenever possible, do not show the user the use of the `DelegateComponent` trait. Instead explain to them using high level concepts, such as that a type-level table is constructed for `MyComponents` using `delegate_components!`.

### `IsProviderFor` Delegation

- The `delegate_components!` macro also generates the `IsProviderFor` implementation in addition to the `DelegateComponent` trait.

- So given the code:

```rust
delegate_components! {
    MyComponents {
        FooComponent:
            FooBarProvider,
    }
}
```

the full desugaring is actually:

```rust
impl DelegateComponent<FooComponent> for MyComponents {
    type Delegate = FooBarProvider;
}

impl<Context, Params> IsProviderFor<FooComponent, Context, Params> for MyComponents
where
    FooBarProvider: IsProviderFor<FooComponent, Context, Params>
{}
```

- This helps the propagation of the provider trait constraints, in case if `MyComponents` is used as a provider and used for a constraint like `MyComponents: FooProvider<MyContext>`.
- Whenever possible, try to avoid mentioning the generation of the `IsProviderFor` implementation inside `delegate_components!`.

## Type-Level List

- CGP commonly uses type-level lists, a.k.a product types, to represent a list of types.
- A type-level list is defined as `Product![A, B, C]`, which is desugared as:

```rust
π<A, π<B, π<C, ε>>>
```

or in a human-readable form:


```rust
Cons<A, Cons<B, Cons<C, Nil>>>
```

- The types `Cons` and `Nil` are defined as:

```rust
pub struct π<Head, Tail>(pub Head, pub Tail);
pub struct ε;
pub use {ε as Nil, π as Cons};
```

- The greek alphabets like `π` and `ε` are used to shorten the representation of these types when displayed by the Rust compiler in places like error messages.
    - Whenever possible, you should prefer the syntactic sugar forms like `Product!` or the human readable forms like `Cons`.

## Type-Level Strings

- CGP uses type-level strings to represent field names as types, in the form of `Symbol!("string value")`.
- The macro desugars a type-level string like `Symbol!("abc")` into follows:

```rust
ψ<3, ζ<'a', ζ<'b', ζ<'c', ε>>>>
```

or in a readable form:

```rust
Symbol<3, Chars<'a', Chars<'b', Chars<'c', Nil>>>>
```

- The types `Symbol` and `Chars` are defined as:

```rust
pub struct ζ<const CHAR: char, Tail>(pub PhantomData<Tail>);
pub struct ψ<const LEN: usize, Chars>(pub PhantomData<Chars>);
pub use {ψ as Symbol, ζ as Chars};
```

- The `Chars` type is essentially a short hand for defining a type-level list of characters.
- The `Symbol` type is used to compute the string length at compile time. This is to workaround the lack of const-generics evaluation in stable Rust.

## `Index` Type

- CGP supports use of type-level natural numbers through the `Index` type, a.k.a. `δ`, which is defined as:

```rust
pub struct δ<const I: usize>;
pub use δ as Index;
```

- The `Index` type can be used to represent indices as types, such as `Index<0>`, `δ<1>`.

## `HasField` Trait

- The most basic use case for CGP is for dependency injection of getting values from the context.
- This is done through the `HasField` trait, which is defined as follows:

```rust
pub trait HasField<Tag> {
    type Value;

    fn get_field(&self, _tag: PhantomData<Tag>) -> &Self::Value;
}
```

- The `Tag` type is used to refer to a field in a struct, such as `Symbol!("name")` or `Index<0>`.
- The `_tag` parameter with `PhantomData` type is used to assist type inference to inform the Rust compiler of the `Tag` type, in case when multiple `HasField` implementations are in scope.
- The `HasField` trait can be automatically derived. For example:

```rust
#[derive(HasField)]
pub struct Person {
    pub name: String,
    pub age: u8,
}
```

will generate the following `HasField` impls:

```rust
impl HasField<Symbol!("name")> for Person {
    type Value = String;

    fn value(&self, _tag: PhantomData<Symbol!("name")>) -> &String {
        &self.name
    }
}

impl HasField<Symbol!("age")> for Person {
    type Value = u8;

    fn value(&self, _tag: PhantomData<Symbol!("age")>) -> &u8 {
        &self.age
    }
}
```

- The `HasField` trait can also derived for structs with unnamed fields, and uses `Index` to refer to the field indices. For example:

```rust
#[derive(HasField)]
pub struct Person(String);
```

will generate:

```rust
impl HasField<Index<0>> for Person {
    type Value = String;

    fn value(&self, _tag: PhantomData<Index<0>>) -> &String {
        &self.0
    }
}
```

## Dependency Injection

- CGP leverages Rust's trait system to enable dependency injection, also called impl-side dependencies.
- The dependency injection is done in the form of constraints specified only in the `where` clause of `impl` blocks, but not in the trait definition.
- For example, given:

```rust
#[cgp_component(Greeter)]
pub trait CanGreet {
    fn greet(&self);
}
```

Using `HasField`, one can perform dependency injection to retrieve a string value from the context, and implement a `Greeter` provider as follows:

```rust
pub struct GreetHello;

impl<Context> Greeter<Context> for GreetHello
where
    Context: HasField<Symbol!("name"), Value = String>,
{
    fn greet(context: &Context) {
        println!("Hello, {}!", context.get_field(PhantomData));
    }
}
```

- This allows `CanGreet` to be implemented on any concrete context struct that derives `HasField` and contains a `name` field of type `String`. For example:

```rust
#[derive(HasField)]
pub struct Person {
    pub name: String,
}

delegate_components! {
    Person {
        GreeterComponent:
            GreetHello,
    }
}
```

- The dependency injection technique can also be used in vanilla Rust traits with blanket implementations, such as:

```rust
pub trait CanGreet {
    fn greet(&self);
}

impl<Context> Greeter for Context
where
    Context: HasField<Symbol!("name"), Value = String>,
{
    fn greet(&self) {
        println!("Hello, {}!", self.get_field(PhantomData));
    }
}
```

- This is commonly used to hide the constraints of one implementation behind a trait interface, without using `#[cgp_component]` to enable multiple alternative implementations.
    - This is useful to simplify the learning curve of CGP, as users can mostly work with vanilla Rust traits.

## `#[cgp_auto_getter]` Macro

- `#[cgp_auto_getter]` macro provides additional abstraction on top of `HasField`, so that users don't need to understand the internals of `HasField`.
- For example, given:

```rust
#[cgp_auto_getter]
pub trait HasName {
    fn name(&self) -> &String;
}
```

the macro would generate the following blanket implementation:

```rust
impl<Context> HasName for Context
where
    Context: HasField<Symbol!("name"), Value = String>,
{
    fn name(&self) -> &str {
        self.get_field(PhantomData).as_str()
    }
}
```

- The `#[cgp_auto_getter]` macro generates blanket impls that use `HasField` implementations with the field name as the `Tag` type, and the return type as the `Value` type.
- The macro supports short hand for several return types such as `&str`, to make the `name` method more ergonomic. So we can rewrite the same trait as:

```rust
#[cgp_auto_getter]
pub trait HasName {
    fn name(&self) -> &str;
}
```

## `#[cgp_getter]` Macro

- The `#[cgp_getter]` macro is an extension to `#[cgp_component]` that provides similar feature as `#[cgp_auto_getter]`, but allows the getter field to be customized through CGP.
- For example, given:

```rust
#[cgp_getter]
pub trait HasName {
    fn name(&self) -> &str;
}
```

is the same as writing:

```rust
#[cgp_component(NameGetter)]
pub trait HasName {
    fn name(&self) -> &str;
}
```

but also has the following `UseField` provider implemented:

```rust
#[cgp_impl(UseField<Tag>)]
impl<Context, Tag> NameGetter for Context
where
    Context: HasField<Tag, Value = String>,
{
    fn name(&self) -> &str {
        self.get_field(PhantomData)
    }
}
```

## `UseField` Pattern

- CGP defines the `UseField` type as a general target for implementing getter providers by `#[cgp_getter]`.
- The `UseField` provider accepts a generic `Tag` parameter that represents the name of the field from the context to be used to implement the getter.
- The `Tag` in `UseField` can use a different name as the getter method, allowing greater flexibility than `#[cgp_auto_getter]` which always require the context to have a field with the exact same name.
- For example, one can have the following wiring:

```rust
#[derive(HasField)]
pub struct Person {
    pub person_name: String,
}

delegate_components! {
    Person {
        NameGetterComponent:
            UseField<Symbol!("person_name")>,
    }
}
```

the example `UseField` provider will use the `person_name` field in `Person` to implement the `NameGetter::name`.

- Whenever possible, explain the `UseField` provider by saying that it implements the getter trait by reading from the context the field name specified.
    - For example, `Person` implements `HasName` using its `person_name` field.

## Abstract Types

- CGP supports abstract types by defining associated types in CGP traits. For example:

```rust
#[cgp_component(NameTypeProviderComponent)]
pub trait HasNameType {
    type Name;
}
```

- The abstract type can be used in another trait interface as the super trait, such as:

```rust
#[cgp_auto_getter]
pub trait HasName: HasNameType {
    fn name(&name) -> &Self::Name;
}
```

## `#[cgp_type]` Macro

- CGP provides the `#[cgp_type]` macro that can be used in place of `#[cgp_component]` to define abstract type traits.
- For example, the `HasNameType` trait can be redefined as:

```rust
#[cgp_type]
pub trait HasNameType {
    type Name;
}
```

- If no provider name is given in `#[cgp_type]`, a default provider name with the type name plus `TypeProvider` postfix is used. So the above code is the same as:

```rust
#[cgp_type(NameTypeProvider)]
pub trait HasNameType {
    type Name;
}
```

- `#[cgp_type]` has the same base behavior as `#[cgp_component]`, but generates additional constructs such as a blanket implementation for `UseType`:

```rust
#[cgp_impl(UseType<Name>)]
impl<Context, Name> NameTypeProvider for Context {
    type Name = Name;
}
```

- The `UseType` struct is defined by CGP, which is implemented by providers that use `#[cgp_type]` as a design pattern.
- The `UseType` pattern allows a concrete context to implement an abstract type by delegating it to `UseType`. For example:

```rust
delegate_components! {
    Person {
        NameTypeProviderComponent:
            UseType<String>,
    }
}
```

would implement `HasNameType` for `Person` with `Name` being implemented as `String`.

## Generic Parameters

- CGP traits can also contain generic parameters, for example:

```rust
#[cgp_component(ValueDeserializer)]
pub trait CanDeserializeValue<'de, Value> {
    fn deserialize<D>(&self, deserializer: D) -> Result<Value, D::Error>
    where
        D: serde::Deserializer<'de>;
}
```

defines a modular version of `serde`'s `Deserialize` trait, with the value serialization provider configurable for each context.

- When the provider trait is generated, the generic parameters are appended after the `Context` parameter.
- In the `IsProviderFor` supertrait, all generic parameters a grouped together into a tuple and placed in the last `Params` position.
- Lifetime generic parameters are wrapped in the `Life` type, which lifts lifetimes into types:

```rust
pub struct Life<'a>(pub PhantomData<*mut &'a ()>);
````

- For example, the `ValueDeserializer` provider trait would be defined as:

```rust
pub trait ValueDeserializer<'de, Context, Value>:
    IsProviderFor<ValueDeserializerComponent, Context, (Life<'de>, Value)>
{
    fn deserialize<D>(context: &Context, deserializer: D) -> Result<Value, D::Error>
    where
        D: serde::Deserializer<'de>;
}
```

## `UseDelegate` Provider

- For traits containing generic parameters, the `#[cgp_component]` macro supports additional option to generate `UseDelegate` providers that dispatch providers based on the generic type using an inner table.

- For example, given:

```rust
#[cgp_component {
    provider: ValueDeserializer,
    derive_delegate: UseDelegate<Value>,
}]
pub trait CanDeserializeValue<'de, Value> {
    fn deserialize<D>(&self, deserializer: D) -> Result<Value, D::Error>
    where
        D: serde::Deserializer<'de>;
}
```

The following provider will be generated:

```rust
#[cgp_impl(UseDelegate<Components>)]
impl<'de, Context, Value, Components> ValueDeserializer<'de, Value> for Context
where
    Components: DelegateComponent<Value>,
    Components::Delegate: ValueDeserializer<'de, Value>,
{
    fn deserialize<D>(&self, deserializer: D) -> Result<Value, D::Error>
    where
        D: serde::Deserializer<'de>
    {
        Components::Delegate::deserialize(self, deserializer)
    }
}
```

- Only the generic type specified in `UseDelegate`'s generic parameter will be used as the key. For example, the `UseDelegate` provider above dispatches based on `Value`, but not `'de`.
- The `UseDelegate` type is defined by CGP, but one can define and use other delegate providers in similar ways. For example:

```rust
pub struct UseInputDelegate;

#[cgp_component {
    provider: Computer,
    derive_delegate: [
        UseDelegate<Code>,
        UseInputDelegate<Input>,
    ],
}]
pub trait CanCompute<Code, Input> {
    type Output;

    fn compute(&self, _code: PhantomData<Code>, input: Input) -> Self::Output;
}
```

the `CanCompute` trait above defines two delegate providers. The default `UseDelegate` provider dispatches based on the `Code` type, while the local `UseInputDelegate` provider dispatches based on the `Input` type.

## Nested Table Definition

- `delegate_components!` supports defining nested type-level tables within the outer table definition.
- For example:

```rust
delegate_components! {
    MyApp {
        ErrorTypeProviderComponent:
            UseType<anyhow::Error>,
        ValueSerializerComponent:
            UseDelegate<new ValueSerializerComponents {
                u64: UseSerde,
                Person: SerializeWithDisplay,
                ...
            }>,
        ...
    }
}
```

is the same as:

```rust
delegate_components! {
    MyApp {
        ErrorTypeProviderComponent:
            UseType<anyhow::Error>,
        ValueSerializerComponent:
            UseDelegate<ValueSerializerComponents>,
        ...
    }
}

delegate_components! {
    new ValueSerializerComponents {
        u64: UseSerde,
        Person: SerializeWithDisplay,
        ...
    }
}
```

The example above helps `App` to implement `CanSerializeValue<u64>` by delegating to the `UseSerde` provider, and `CanSerializeValue<Person>` to `SerializeWithDisplay`, via the `UseDelegate` provider using `ValueSerializerComponents` as the inner lookup table based on the `Value` types.

## `CanUseComponent` Check Trait

- The CGP component wiring is lazy, i.e. when a `DelegateComponent` impl is defined, the type system doesn't check whether the corresponding traits are truly implemented by a context with all transitive dependencies satisfied.
- When a consumer trait is used with a context, but there are unsatisfied dependencies, the compiler will produce short error messages that are difficult to debug and identify the root cause.
- To ensure that a consumer is implemented by a context, we implement check traits to assert at compile time that the wiring is complete.
- The `CanUseComponent` trait is a check trait defined as follows:

```rust
pub trait CanUseComponent<Component, Params: ?Sized = ()> {}

impl<Context, Component, Params: ?Sized> CanUseComponent<Component, Params> for Context
where
    Context: DelegateComponent<Component>,
    Context::Delegate: IsProviderFor<Component, Context, Params>,
{}
```

- `CanUseComponent` for a CGP component is automatically implemented for a context, if a context delegates the component to a provider, and the provider implements the provider trait for that context.
- The check is done via `IsProviderFor`, to ensure that the compiler generates appropriate error messages when there is any unsatisfied constraint.
    - Without `IsProviderFor`, Rust would conceal the indirect errors and only show that the provider trait is not implemented without providing further details.

## `check_components!` Macro

- The `check_components!` macro generates code that checks the CGP wiring of components using `CanUseComponent`.
- For example, given:

```rust
#[cgp_auto_getter]
pub trait HasName {
    fn name(&self) -> &str;
}

#[cgp_component(Greeter)]
pub trait CanGreet {
    fn greet(&self);
}

#[cgp_impl(new GreetHello)]
impl<Context> Greeter for Context
where
    Context: HasName,
{
    fn greet(&self) {
        println!("Hello, {}!", self.name());
    }
}

#[derive(HasField)]
pub struct Person {
    pub first_name: String,
}

delegate_components! {
    Person {
        GreeterComponent:
            GreetHello,
    }
}
```

- The `Person` struct above incorrectly contains a `first_name` field, instead of the `name` field expected by `GreetHello` via `HasName`.
- The static check is written with `check_components!` as follow:

```rust
check_components! {
    CanUsePerson for Person {
        GreeterComponent,
    }
}
```

- Behind the scenes, the macro desugars the code above to:

```rust
trait CanUsePerson<Component, Params: ?Sized>: CanUseComponent<Component, Params> {}
impl CanUsePerson<GreeterComponent, ()> for Person {}
```

- The auxilary `CanUsePerson` trait is defined as a local alias to check the use of `CanUseComponent` with the same parameters.
- For each `Component` listed in `check_components!`, an impl block for `CanUsePerson` is defined.
- The example implementation `CanUsePerson<GreeterComponent, ()>` is implemented only if:
    - `Person` implements `CanUseComponent<Component, Params>`.
    - `Person`'s delegate for `GreeterComponent`, `GreetHello`, implements `IsProviderFor<GreeterComponent, Person, ()>`.
    - Recall that `#[cgp_impl]` or `#[cgp_provider]` generates the implementation of `GreetHello: IsProviderFor<GreeterComponent, Person, ()>` with the same constraints required for `GreetHello` to implement `Greeter<Person>`.
- Since the `name` field is missing, the compiler reports the error that `HasField<symbol!("name")>` is not implemented for `Person`.
    - The root cause is often hidden among many other non-essential messages, and types such as `symbol!("name")` are expanded into their Greek alphabets form.

## Generic Parameters in `check_components!`

- `check_components!` can only be used with generic parameters. For example:

```rust
check_components! {
    <'de> CanUseAppDerializer for App {
        ValueDeserializerComponent: (Life<'de>, u64),
    }
}
```

would be desugared to:

```rust
trait CanUseAppDerializer<Component, Params: ?Sized>:
    CanUseComponent<Component, Params>
{
}
impl<'de> CanUseAppDerializer<ValueDeserializerComponent, (Life<'de>, u64)> for App {}
```

which would check for the implementation of `App: CanDeserializeValue<'de, u64>`.

- The generic parameters are grouped into a tuple and placed in `Params`.

## Array Syntax in `check_components!`

- When we want to check the implementation of a CGP component with multiple generic parameters, we can use the array syntax to group them together. For example:

```rust
check_components! {
    CanUseAppSerializer for App {
        ValueSerializerComponent: [
            u64,
            String,
        ],
    }
}
```

is the same as writing:

```rust
check_components! {
    CanUseAppSerializer for App {
        ValueSerializerComponent: u64,
        ValueSerializerComponent: String,
    }
}
```

- We can also group by the `Component` key instead of the generic `Param`. For example:

```rust
check_components! {
    CanUseAppSerializer for App {
        [
            ValueSerializerComponent,
            AreaCalculatorComponent,
        ]: Circle,
    }
}
```

- We can also group by both `Component` and `Param`. For example:

```rust
check_components! {
    CanUseAppSerializer for App {
        [
            ValueSerializerComponent,
            AreaCalculatorComponent,
        ]: [
            Circle,
            Rectangle,
        ],
    }
}
```

would be the same as writing:


```rust
check_components! {
    CanUseAppSerializer for App {
        ValueSerializerComponent: Circle,
        AreaCalculatorComponent: Circle,
        ValueSerializerComponent: Rectangle,
        AreaCalculatorComponent: Rectangle,
    }
}
```


# General Instructions

- When interacting with the user, assume that the user only has basic Rust programming experience and is not familiar with any concept in CGP.
- Only provide further explanation for CGP concepts if the user asks for the specific explanation. Otherwise, assume that the user already understand the CGP concepts used in the code.

- When the user asks you to explain CGP concepts:
    - You should assume that the user is not familiar with advanced Rust concepts, including generics, traits, blanket implementations, and the coherence problem.
    - You should assume that the user is not familiar with functional programming and type-level programming concepts. So try to explain concepts like type-level tables, lists, or string, using more familiar OOP concepts, such as v-table lookup.
    - Use full sentences and explain CGP concepts in ways that are approachable and engaging to beginners. You should include additional explanation for advanced concepts such as generics when applicable.

- When the user ask to explain a specific wiring in `delegate_components!`, always lookup the definition of the components and providers to give more details in your explanation. For example, if the user asks you to explain the following code:

```rust
delegate_components! {
    Person {
        GretterComponent:
            GreetHello,
    }
}
```

you should look up for the definitions of `GreetComponent` and `GreetHello`. This includes finding out what are the names of the consumer trait and provider trait for `GreetComponent`, and the trait or impl body.

- When the user asks about the implementation details of a provider, always perform lookup on the original definition, and also the definition of all dependencies that the provider uses. For example, if the user asks you to explain the following:

```rust
#[cgp_impl(GreetHello)]
impl<Context> Greeter for Context
where
    Context: HasName,
{
    fn greet(&self) {
        println!("Hello, {}!", self.name());
    }
}
```

you should lookup for the definition of `Greeter` and `HasName`, and include the details of those definitions in your explanation.

- When the user asks about how a provider is implemented for a context, also perform lookup based on the specific wiring for the context, and find out what other providers that implementation is linked to. For example, if you need to explain `GreetHello`, and you find the following wiring:

```rust
delegate_components! {
    Person {
        NameGetterComponent:
            UseField<"person_name">,
        GretterComponent:
            GreetHello,
    }
}
```

then you should explain that for the `Person` context, since `NameGetterComponent` is wired to `UseField<"person_name">`, so when `println!("Hello, {}!", self.name())` is called from `GreetHello`, the value from `person_name` field will be returned from `self.name()`.
